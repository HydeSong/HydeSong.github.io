[{"title":"小程序开放新能力","date":"2017-03-30T07:38:30.000Z","path":"2017/03/30/mini/","text":"为帮助开发者提供更加丰富的服务，小程序新增： 1、低功耗蓝牙小程序可以搜索和连接周边的蓝牙设备，并与之通讯。 2、卡券能力 开发者可在小程序中应用卡券能力。小程序内支持领取卡券，会员卡内可直达小程序服务 ，方便用户享受会员权益。 3、共享微信通讯地址经用户授权后，小程序可以直接获取用户在微信中保存的通讯地址，不必再让用户重复输入。 4、获取用户访问场景开发者可以获知当前用户进入小程序的渠道，从而提供差异化服务。如针对到店扫码访问小程序的顾客，发放专属优惠。 5、兼容ES6 API开发者可以在小程序中使用ES6的绝大多数API，而不用考虑JavaScript版本兼容问题。","tags":[{"name":"小程序","slug":"小程序","permalink":"//hydesong.github.io/tags/小程序/"}]},{"title":"FIZZO发布运动心率解决方案，开启健身3.0时代","date":"2017-03-29T08:25:23.000Z","path":"2017/03/29/sports/","text":"2017年3月2日下午，第五区运动科技旗下品牌FIZZO，在IWF中国（上海）国际健身、康体休闲展览会，发布了其最新的运动心率解决方案产品，包括FIZZO COR运动心率手环、用于健身房的FIZZO HUB心率监控盒子，以及FIZZO CLOUD智能健身云平台。 FIZZO运动心率解决方案发布会现场 从心出发，开启健身3.0时代 FIZZO创始人程晓伟先生，定义健身3.0时代为健身智能化时代。他认为，1.0是指20年前开始的传统健身房形态；2.0是乐刻超级猩猩等为代表的信息化小型化潮流；3.0则是智能化时代，指以可穿戴设备为入口，以运动生理数据为基础，以大数据和人工智能技术为引擎，为会员提供个性化精准化的服务为特征。3.0时代会达到真正的全民健身。 心率数据是判断运动强度、运动疲劳程度，评估运动效果的重要指标。 FIZZO运动心率解决方案就是从运动心率出发，帮助健身行业实现真正的智能化。 FIZZO，BE IN THE ZONE 致力于服务全民运动健康 除了健身行业之外，FIZZO还有更大的目标：服务全民运动健康。程晓伟先生认为，对于大部分人来说，坚持健身和运动，是因为对生病和死亡的恐惧，所以只有能够打中这个人性基本点，公司业务形态才可以长久。 FIZZO的目标是通过为用户提供有氧运动处方，帮助用户远离“七高”。“七高”是包括高体脂比(肥胖)、高血压、高血脂、高血糖、脂肪肝、高尿酸、高胆固醇。“七高”会引起心脑血管血栓、心梗、脑梗、癌症、肝硬化等致命病症。程总认为，欧洲、美国、加拿大、日本等国的运动医学专家，已经用50年研究成果已经充分表明，有氧运动可以减轻，或者彻底解决大部分七高问题。 FIZZO运动心率解决方案产品 FIZZO运动心率产品框架图 FIZZO COR 运动心率手环 以往运动心率的监测，需要依靠心率带。佩戴不舒适，动作幅度较大时，容易产生位移，导致测量数据不准。近几年光电心率产品纷涌而出，解决了心率带佩戴不方便的问题，但其准确度却常常被诟病。 如何兼顾佩戴舒适性、应用广泛性和数据准确性成了运动心率设备厂商们的难题。 FIZZO COR运动心率手环样机图 面对这个难题，FIZZO迎难而上，经过22个月的潜心研发，攻克了这一难关，推出了自主研发的抗运动干扰心率监测技术“Skylark”，以及第一代运动心率手环FIZZO COR。 FIZZO展台数据准确度PK现场 展会现场FIZZO展台用大屏幕直播数据对比图，将FIZZO手环与国际著名专业级心率带和手环公开同台PK。事实证明，FIZZO手环的实时心率数据与最专业的Polar心率带数据相比，无论是精准度还是跟随性都达到了可以取代心率带的程度。 FIZZO HUB 心率监控盒子 心率监控盒子概念图和大屏幕实时心率显示页面 FIZZO HUB心率监控盒子，是FIZZO专门为健身房环境开发的多人心率监控系统。FIZZO HUB通过大屏幕实时显示多人心率，方便健身教练对会员训练过程进行实时监控。 FIZZO CLOUD智能健身云平台 FIZZO CLOUD智能健身云平台 ，基于穿戴设备获取的生理大数据，分析并实时计算会员晨起疲劳度、有氧耐力、肌耐力、过程运动量、过程疲劳度等参数，根据这些数据，为教练提供学员能力评估、训练效果评价等功能，为制定个性化训练方案提供数据依据。 关于创始人程晓伟先生 创始人 程晓伟 第五区运动科技创始人程晓伟，前德州仪器市场拓展总监、清华大学EE硕士，同时也是资深运动爱好者。曾任第三届玄奘之路戈壁挑战赛长江商学院代表队队长，并获团体冠军。热爱骑行，曾经骑行滇藏线从香格里拉到达拉萨。也是马拉松跑者，已经完成6个全程马拉松。 每年会参与多场马拉松赛事将自己擅长的能力和爱好结合，是程晓伟先生选择运动健康数据服务类项目创业的原因。对于他来说，这次创业不仅仅是创立一家公司，创造一种产品，更是深深地植入了自己热爱运动、信仰运动改变人生、传播运动健康理念的情怀。 关于我们 25年行业沉淀，积累厚积薄发的实力；5年行业观察，紧握关键的创新契机；2年潜心研发，只为高品质中国智造。 第五区运动科技由世界500强的高管创立，核心团队由毕业于清华大学、上海交大、佐治亚理工、苏黎世联邦理工等国内外名校的精英组成。公司专注于运动健康的数据化和智能化，致力成为全球运动健康个性化解决方案的领导者。","tags":[{"name":"随笔","slug":"随笔","permalink":"//hydesong.github.io/tags/随笔/"}]},{"title":"js模块 Modules","date":"2017-03-29T08:22:59.000Z","path":"2017/03/29/new/","text":"早在2007年我刚加入Mozilla的JavaScript团队的时候广为流传一个笑话：通常来说JavaScript程序的长度只有一行。 那时候Google Maps的诞龄还只有两岁，在它诞生之前，JavaScript主要被用来验证表单，毫无疑问，每一个处理&lt;input onchange=&gt;的程序真的就只有一行代码。 今非昔比，JavaScript项目的规模已经成长到令人惊叹的地步，社区也开发了很多工具来协助构建这些规模庞大的应用。诸多工具中最核心的非模块系统莫 属，在这样一个系统中，你可以通过多个文件和目录来组织你的项目，最重要的是，所有代码都可以按需彼此访问并高效加载。所以JavaScript就这么顺 理成章地拥也了几个知名的模块系统。当然，随之而来的还有几个包管理器，可以用它们安装所有软件以及处理高层次的依赖。如此一来，你一定会觉得ES6的模 块语法真是姗姗来迟啊。 好的，那今天我们就一起看看ES6中新增的模块系统，探讨一下我们可以通过新语法打造什么样的工具并进一步推动未来标准的发展。但是首先，我们还是来了解一下ES6模块的基础知识。 模块基础知识每一个ES6模块都是一个包含JS代码的文件，模块本质上就是一段脚本，而不是用module关键字定义一个模块，但是模块与脚本还是有两点区别： 在ES6模块中，无论你是否加入“use strict;”语句，默认情况下模块都是在严格模式下运行。 在模块中你可以使用import和export关键字。 我们先来讨论export。默认情况下，你在模块中的所有声明相对于模块而言都是寄存在本地的。如果你希望公开在模块中声明的内容，并让其它模块加以使用，你一定要导出这些功能。想要导出模块的功能有很多方法，其中最简单的方式是添加export关键字。123456789101112131415// kittydar.js - 找到一幅图像中所有猫的位置// （事实上是Heather Arthur写的这个库）// （但是她没有使用ES6中新的模块特性，因为那时候是2013年）export function detectCats(canvas, options) &#123; var kittydar = new Kittydar(options); return kittydar.detectCats(canvas);&#125;export class Kittydar &#123; ... 处理图片的几种方法 ...&#125;// 这个helper函数没有被export。function resizeCanvas() &#123; ...&#125;... 你可以导出所有的最外层函数、类以及var、let或const声明的变量。了解这些，你就可以编写一个简单的模块。你不需要将所有代码都放在一个IIFE或回调中，你只需要在模块中解放手脚，声明你需要的所有内容。代码就是模块，不是一段脚本，所以所有的声明都被限定在模块的作用域中，对所有脚本和模块全局不可见。你需要做的是将组成模块公共API的声明全部导出。 在模块中，除export之外的代码无异于普通代码，你可以访问类似Object和Array这样的全局对象。如果你在web浏览器中运行模块，你甚至可以使用document对象和XMLHttpRequest对象。 在一个独立文件中，我们可以导入detectCats()函数然后用它来做点儿什么： 1234567// demo.js - Kittydar的demo程序import &#123;detectCats&#125; from \"kittydar.js\";function go() &#123; var canvas = document.getElementById(\"catpix\"); var cats = detectCats(canvas); drawRectangles(canvas, cats);&#125; 如果想从一个模块中导入多个名称，你可以这样写：1import &#123;detectCats, Kittydar&#125; from \"kittydar.js\"; 当你运行的模块中包含一条import声明时，首先会加载被导入的模块；然后依赖图的深度优先遍历按顺序执行每一个模块的主体代码；为了避免形成回环，所有已执行的模块都会被忽略。 这些就是模块的基本知识了，相当简单吧。;-) Export列表你不需要标记每一个被导出的特性，你只需要在花括号中按照列表的格式写下你想导出的所有名称：1234export &#123;detectCats, Kittydar&#125;;// 此处不需要 `export`关键字function detectCats(canvas, options) &#123; ... &#125;class Kittydar &#123; ... &#125; export列表可以在模块文件最外层作用域的每一处声明，不一定非要把它放在模块文件的首行。你也可以声明多个export列表，甚至通过其它的export声明打造一个混合的export列表，只要保证每一个被导出的名称是唯一的即可。 重命名import和export恰恰有时候，导出的名称会与你需要使用的其它名称产生冲突，ES6为你提供了重命名的方法解决这个问题，当你在导入名称时可以这样做： 123456// suburbia.js// 这两个模块都会导出以`flip`命名的东西。// 要同时导入两者，我们至少要将其中一个的名称改掉。import &#123;flip as flipOmelet&#125; from \"eggs.js\";import &#123;flip as flipHouse&#125; from \"real-estate.js\";... 同样，当你在导出的时候也可以重命名。你可能会想用两个不同的名称导出相同的值，这样的情况偶尔也会遇到： 1234567891011// unlicensed_nuclear_accelerator.js - 无DRM（数字版权管理）的媒体流// （这不是一个真实存在的库，但是或许它应该被做成一个库）function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; Default exports现在广泛使用的模块系统有CommonJS、AMD两种，设计出来的新标准可以与这两种模块进行交互。所以假设你有一个Node项目，你已经执行了npm install lodash，你的ES6模块可以从Lodash中导入独立的函数：123import &#123;each, map&#125; from \"lodash\";each([3, 2, 1], x =&gt; console.log(x)); 但是也许你已经习惯看到.each的书写方式而不想直接用each函数呢？或者你就真的想导入整个函数呢，毕竟_对于Lodash而言至关重要。 针对这种情况，你可以换用一种稍微不太一样的方法：不用花括号来导入模块。 1import _ from \"lodash\"; 这种简略的表达方法等价于import {default as _} from “lodash”;。在ES6的模块中导入的CommonJS模块和AMD模块都有一个默认的导出，如果你用require()加载这些模块也会得到相同的结果——exports对象。 ES6模块不只导出CommonJS模块，它的设计逻辑为你提供导出不同内容的多种方法，默认导出的是你得到的所有内容。举个例子，在用这种写法的时候，据我所知，著名的colors包就没有任何针对ES6的支持。像大多数npm上的包一样，它是诸多CommonJS模块的集合，但是你可以正确地将它导入到你的ES6代码中。 12// `var colors = require(\"colors/safe\");`的ES6等效代码import colors from \"colors/safe\"; 如果你想让自己的ES6模块有一个默认的导出，实现的方法很简单，默认导出与其它类型的导出相似，没有什么技巧可言，唯一的不同之处是它被命名为“default”。你可以用我们刚才讨论的重命名语法来实现： 12345let myObject = &#123; field1: value1, field2: value2&#125;;export &#123;myObject as default&#125;; 这种简略的表达方法看起来更清爽：1234export default &#123; field1: value1, field2: value2&#125;; 关键字export default后可跟随任何值：一个函数、一个类、一个对象字面量，只要你能想到的都可以。 模块对象很抱歉新特性有点儿多，但JavaScript不是唯一这样做的语言：出于某些原因，每一种语言中的模块系统都有这么一堆又独立又小，虽然无聊但是很方便的特性。不过还好，我们只剩一样东西没讲了。好吧，是两样。1import * as cows from \"cows\"; 当你import *时，导入的其实是一个模块命名空间对象，模块将它的所有属性都导出了。所以如果“cows”模块导出一个名为moon()的函数，然后用上面这种方法“cows”将其全部导入后，你就可以这样调用函数了：cows.moo()。 聚合模块有时一个程序包中主模块的代码比较多，为了简化这样的代码，可以用一种统一的方式将其它模块中的内容聚合在一起导出，可以通过这种简单的方式将所有所需内容导入再导出：12345678910// world-foods.js - 来自世界各地的好东西// 导入\"sri-lanka\"并将它导出的内容的一部分重新导出export &#123;Tea, Cinnamon&#125; from \"sri-lanka\";// 导入\"equatorial-guinea\"并将它导出的内容的一部分重新导出export &#123;Coffee, Cocoa&#125; from \"equatorial-guinea\";// 导入\"singapore\"并将它导出的内容全部导出export * from \"singapore\"; 这些export-from语句每一个都好比是在一条import-from语句后伴随着一个export。与真正的导入内容的方法不同的是，这些导入内容再重新导出的方法不会在作用域中绑定你导入的内容。如果你打算用world-foods.js中的Tea来写一些代码，可别用这种方法导入模块，你会发现当前模块作用域中根本找不到Tea。 如果从“singapore”导出的任何名称碰巧与其它的导出冲突了，可能会触发一个错误，所以使用export *语句的时候要格外小心。 呼！终于讲完了所有的语法！现在来讲一些有趣的内容。 import实际都做了些什么？如果我说它什么都没做，你敢信？ 哦，看来你没那么容易上当啊。好吧，你相信标准里面通常都不会规定import的行为么？如果真是这样，那这是件好事儿么？ ES6将模块加载过程的细节完全交由最终的实现来定义，模块执行的其它部分倒是在规范中有详细定义。 粗略地讲，当你通知JS引擎运行一个模块时，它一定会按照以下四个步骤执行下去： 语法解析：阅读模块源代码，检查语法错误。 加载：递归地加载所有被导入的模块。这也正是没被标准化的部分。 连接：每遇到一个新加载的模块，为其创建作用域并将模块内声明的所有绑定填充到该作用域中，其中包括由其它模块导入的内容。 如果你的代码中有import {cake} from “paleo”这样的语句，而此时“paleo”模块并没有导出任何“cake”，你就会触发一个错误。这实在是太糟糕了，你都快要运行模块中的代码了，都是cake惹的祸！ 运行时：最终，在每一个新加载的模块体内执行所有语句。此时，导入的过程就已经结束了，所以当执行到达有一行import声明的代码的时候……什么都没发生！看到了嘛？我可告诉过你结果是“啥都没有”哦。事关编程语言我绝不撒谎！ 但是现在我们真的要深入了解这个系统最有趣的部分了！有一个很酷的小技巧我可以教给你。系统不指定加载过程的实现方式，你也可以通过在源代码中查找import声明提前计算出所有依赖，你可以将ES6系统实现为：在编译时计算所有依赖并将所有模块打包成一个文件，通过网络一次传输所有模块！像webpack这样的工具就实现了这个功能。 这种做法的意义非常深远，因为通过网络加载脚本需要花费时间，每当你请求到一个模块，你可能发现它里面也包含着import声 明，这就需要你再花费一些时间加载更多的脚本。基于如此天真的思想实现的加载器需要消耗更多的网络往返时间。但是webpack就不一样啦，它所用的加载 器是经过精心设计的，吸收了软件工程领域的精华，所以你不仅可以立即开始使用ES6模块系统，还不会损耗运行时的性能。 最初的时候，标准委员会已经制定并实现了详细的ES6模块加载标准，它未成为最终的标准的原因是成员们没有就代码封包（bundle）功能的实现方式达成一 致意见。我希望有人能搞定这个问题，正如我们所见，模块加载的过程亟待被标准化；最关键的是，封包的功能实在是太好，就这样放弃对其进行标准化有些可惜啊。 静态vs动态：论规则及破例之法JavaScript作为一门动态语言已经得到了一个令人惊讶的静态模块系统。 你只可以在模块的最外层作用域使用import和export，不可在条件语句中使用，也不能在函数作用域中使用import。 所有导出的标识符一定要在源代码中明确地导出它们的名称，你不能通过编写代码遍历一个数组然后用数据驱动的方式导出一堆名称。 模块对象被冻结了，所以你无法hack模块对象并为其添加polyfill风格的新特性。 一个模块的所有依赖必须在模块代码运行前完全加载、解析并且及早连接，不存在一种通过import来按需懒加载的语法。 import模块产生的错误没有错误恢复机制。一个app可能囊括了上百个模块，一旦有一个模块无法加载或连接，所有的模块都不会运行，而且你不能在try/catch代码块中捕捉import的错误信息。（上面这些描述的本意是说：系统是静态的，webpack可在编译时为你检测那些错误。） 不支持在模块加载依赖前运行其它代码的钩子，这也意味着无法控制模块的依赖加载过程。只要你的需求是静态的，系统就会运行良好，但是你有时可以设想下需要一点儿hack，对么？ 这也就是无论你用什么模块加载系统，你都将有一个编程API来支持ES6的静态import/export语法。举个例子，webpack中引入了一个“代码分割”API，从而可以按需懒加载一些模块的多个封包。相同的API可以帮你打破上面列举的绝大多数其它的规则。 ES6模块语法非常静态，这是很好的——它通过强有力的编译时工具的形式进行弥补。但是设计静态语法的初衷是要与丰富的动态编程加载器API一起增强ES6的模块系统。 我什么时候可以使用ES6模块？如果你现在就想在项目中加入新的模块语法，你需要使用Babel或Traceur这样的转译器。在系列之前的文章中，Gastón I. Silva展示了如何使用Babel和Broccoli来为web平台编译ES6代码；在那篇文章的基础上，Gastón准备了一个支持ES6模块的工作示例。Axel Rauschmayer写的这篇文章给出了一个用Babel和webpack构建项目的示例。 ES6模块系统主要由Dave Herman和Sam Tobin-Hochstadt进行设计，在近几年的争论中，他们与所有参与者（包括我）为新模块系统的静态部分进行辩护。Jon Coppeard负责在Firefox中实现这些模块的特性。JavaScript加载器标准也在制定当中，接下来标准委员会可能会为HTML添加一些类似&lt;script type=module&gt;特性。 然后这就是ES6的全部啦。","tags":[{"name":"js模块化","slug":"js模块化","permalink":"//hydesong.github.io/tags/js模块化/"}]},{"title":"JavaScript模块化编程简史（2009-2016）","date":"2017-03-29T08:22:45.000Z","path":"2017/03/29/javascript-modules/","text":"对于任何一个 Web 站点开发者，JavaScript 模块化编程正在变得越来越重要。我们可能已经在开发中使用模块化的开发，但是自己却没有意识到，比如在浏览器中使用 require.js 来异步加载需要的模块，比如在 Node 中使用 require 来引入模块等。 模块化开发的方式一直在改变，从 2009 年就诞生了 CommonJS 规范，在 2015 年的最新的 ES6 中，官方终于引入了对于模块的原生支持。在这段期间发生了哪些变化？在生产环境中究竟使用哪一种最好，我们是否需要刷新一下自己的知识库？ 所以我花了一个周末的时间重新仔细回顾 JavaScript 模块化编程的历史，并且记录下我的学习笔记。 1、解释一下什么是模块（modules）？好的作者把他们的书分为一些章和节，好的程序员把代码分为一些模块。 章节是一些句子聚合在一起，组成一个“主题”。模块就是把一些代码聚合在一起，组成一个“功能”。 好的模块，是高度独立的，它可以被随时加入或者移除，而不会损害系统。 使用模块有这样几个好处： 1）可维护性。 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。 2）命名空间。 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。 3）重用代码。 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免 API 变更带来的麻烦。 2、如何实现模块化？“模块”这种模式有点类似类（classes）。在其他语言中（比如 Java 和 Python），我们可以把相关的属性和函数都放在一个类中。与此同时，我们决定哪些属性和方法对外暴露，作为类的公共 API。不需要公开的属性和方法，隐藏在类内部。 而在 JavaScript 中（在 ES6 之前）不支持类。 因为正好在创建函数的时候，解释器会针对函数产生一个新的运行环境，在函数中声明的对象都只存在于这个运行环境中。由于有这个新运行环境，我们可以随意创建对象，反正函数运行完了之后就会销毁一切。这样就达到了类似私有变量的效果，从而避免父命名空间（也就是全局命名空间）冲突。 所以在 ES6 之前我们都从函数来入手，通过多种方式实现模块化开发，让我们一个一个分析。 2.1、使用匿名函数在这个代码片段中，我们定义了一个匿名函数并立即执行。在这个匿名函数内定义的变量myGrades 等都成为这个运行环境内的私有属性。 要记得的一点是一定要用圆括号把整个匿名函数包起来，因为如果语句直接以function关键词开始，那么这个语句会被认为是一个函数声明（FunctionDeclaration），而不是一个函数语句（FunctionExpression）。 函数声明必须是有名字的，函数语句才可以匿名，所以我们一定需要用括号来把整个函数体括起来。 2.2、把全局函数注入到匿名函数刚才我们使用一个匿名函数把变量和代码封装起来，接下来演示一种常用的做法，就是把全局变量“注入”到匿名函数中。jQuery就是这样用的。 在这个例子中，globalVarible 是唯一一个全局的变量。这种做法比完全匿名的闭包的好处是，代码结构更清晰，而且性能更好。我们能够看到函数内部传递进来了全局变量，所以依赖关系非常清晰。其次在函数内部调用 globalVarible 的时候，解释器能够直接找到局部的 globalVarible，就不用上溯到外部的 globalVarible。 因为是 JavaScript 是引用传值，我们也可以在函数内，对这个全局的 globalVarible 进行修改。 准确说，如果我们直接修改 globalVarible 所指向的“对象指针”，就不会有问题。 比如 globalVarible = “foo”; 不会改变全局的 globalVarible 对象， 但 globalVarible.name = “foo”; 会改变全局的 globalVariable 对象的 name 属性。 2.3、提供一个对象作为接口你可能注意到上面的方式没有区分“私有属性”和“公开属性”。 下面介绍一种创建模块的方法，它使用一个返回的函数，来指定对象接口，就像这样： 立即执行的匿名函数返回了一个对象。通过这种方式，我们可以定义 failing() 和 average() 是公开的接口，而 myGrades 是私有属性。 2.4、把要公开的属性专门放在一个对象声明中返回上一段代码不是很清晰，因为声明跟实现放在一起了，所以改良成更加清晰的代码： 在这段代码中，默认所有的变量和方法都是私有的，只有在最后显示 return 一个对象的时候，才选择性暴露出对外接口，接口很清晰。 3、CommonJS 和 AMD上面这些方法都有一个共同点：使用一个特定的全局模块名来把一些私有变量和方法包起来，然后通过闭包来创建一个私有的命名空间。 这样也就有一个共同的缺点，就是无法管理不同模块之间的依赖关系。比如说，如果我们的项目用到了 Backbone.js 库，所以我们会把 Backbone.js 的代码引入到项目中。 不过，由于 Backbone 依赖 Underscore.js，所以 Backbone.js 的代码需要放在 Underscore.js 之后。 当依赖的库多起来了，记住这些库应该以什么样的顺序去加载就是一件很头疼的事情了。 另一个明显的缺点是，依次引入这些模块仍然没有解决命名空间冲突的问题。比如 jQuery 和其他库可能都使用了 $ 来作为暴露的名字，或者我们引用了同一个模块的两个不同版本怎么办？ 幸运的是，我们有两个已经得到广泛支持的解决方案：CommonJS 和 AMD。 3.1、CommonJSCommonJS 最开始是 Mozilla 的工程师于 2009 年开始的一个项目，它的目的是让浏览器之外的 JavaScript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。 在 CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 如果想在多个文件分享变量，第一种方法是声明为 global 对象的属性。但是这样做是不推荐的，因为大家都给 global 加属性，还是可能冲突。 推荐的做法是，通过 module.exports 对象来暴露对外的接口。 Node 就采用了 CommonJS 规范来实现模块依赖。 我们可以这样创建一个最简单的模块： 我们可以注意到，在定义了自己的 function 之后，通过 module.exports 来暴露了出去。为什么我们可以在没有定义 module 的情况下就使用它？因为 module 是 CommonJS 规范中预先已经定义好的对象，就像 global 一样。 如果其他代码想使用我们的 myModule 模块，只需要 require 它就可以了。 这种做法有两个明显的优势： 避免全局命名空间污染，require 进来的模块可以被赋值到自己随意定义的局部变量中，所以即使是同一个模块的不同版本也可以完美兼容让各个模块的依赖关系变得很清晰语法也非常紧凑，我个人很喜欢。 有的时候我们实现一个模块需要的代码量比较大，会再次分解成若干文件，然后放在一个目录中。这时，我们需要在该目录中放置一个 package.json 文件，在 main 字段中指定一个入口文件（比如index.js）。 这样，其他人就能够使用 require 方法，加载整个目录。 需要注意的是，CommonJS 规范的主要适用场景是服务器端编程，所以采用同步加载模块的策略。如果我们依赖3个模块，代码会一个一个依次加载它们。 因为服务器端的模块加载主要来源硬盘、或者内存，所以加载速度比较快，同步加载并不是很大问题。但是如果是在浏览器场景中，同步加载就有很大问题，因为从网络中加载一个模块比从硬盘加载慢得多。在等待加载的过程中，浏览器会挂起当前的进程，直到模块下载完成。 阮一峰老师实现了一个在浏览器中加载 CommonJS 规范的模块的 JavaScript 库，可以作为学习或者测试模型来使用，但是在生产环境中使用，就有很大的性能问题了。 Node 开发社区的 SubStack 大神开发了一个 browserify 工具。browserify 是一个开发侧解决方案，它可以把需要 require 进来的 a/b/c 等模块文件全部打包合并到一个单独的 JavaScript 文件中（这个过程称为 bundle）。 第一步通过 browserify 命令来合并输出 bundle.js。 第二步，页面中只需要引入一次 bundle.js，就可以得到一个暴露出了对应的 a/b/c 模块的 require 函数，避免了一个一个请求，性能非常好。 3.2、AMD介绍了同步方案，我们当然也有异步方案。在浏览器端，我们更常用 AMD 来实现模块化开发。AMD 是 Asynchronous Module Definition 的简称，即“异步模块定义”。 我们看一下 AMD 模块的使用方式： 在这里，我们使用了 define 函数，并且传入了两个参数。 第一个参数是一个数组，数组中有两个字符串也就是需要依赖的模块名称。AMD 会以一种非阻塞的方式，通过 Ajax 加载这两个模块。在两个模块都加载成功之后，define 会调用第二个参数中的回调函数，一般是函数主体。 第二个参数也就是回调函数，函数接受了两个参数，正好跟前一个数组里面的两个模块名一一对应。因为这里只是一种参数注入，所以我们使用自己喜欢的名称也是完全没问题的。 同时，define 既是一种引用模块的方式，也是定义模块的方式。 例如，myModule 的代码可能看上去是这样： 所以我们可以看到，AMD 优先照顾浏览器的模块加载场景，使用了异步加载和回调的方式，这跟 CommonJS 是截然不同的。 3.3、UMD对于需要同时支持 AMD 和 CommonJS 的模块而言，可以使用 UMD（Universal Module Definition）。 在执行UMD规范时，会优先判断是当前环境是否支持AMD环境，然后再检验是否支持CommonJS环境，否则认为当前环境为浏览器环境（window）。 如果你写了一个小工具库，你想让它及支持AMD规范，又想让他支持CommonJS规范，那么采用UMD规范对你的代码进行包装吧。 4、ES6 模块可能你已经注意到了，上面所有这些模型定义，没有一种是 JavaScript 语言原生支持的。无论是 AMD 还是 CommonJS，这些都是 JavaScript 函数来模拟的。 幸运的是，ES6 开始引入了原生的模块功能。 ES6 的原生模块功能非常棒，它兼顾了规范、语法简约性和异步加载功能。它还支持循环依赖。 最棒的是，import 进来的模块对于调用它的模块来是说是一个活的只读视图，而不是像 CommonJS 一样是一个内存的拷贝。 下面是一个 ES6 模块的示例： 如果只希望导出某个模块的部分属性，或者希望处理命名冲突的问题，可以有这样一些导入方式： 我什么时候可以使用ES6模块？现在就可以用！如果你现在就想在项目中加入新的模块语法，你需要使用 Babel 或 Traceur 这样的转译器。 总结JavaScript 的模块模式是很有意思的话题，期望过几年之后所有的主流浏览器都可以原生支持 ES6 的模块系统，加上 HTTP2 的普及能够让同源请求有更好的性能，那时候我们也许会看到类似 这样的代码。 不过在那之前，我们可以先用 CommonJS（Node是这样做的），或者 AMD（jQuery是这样做的），或者 webpack 这样的“模块打包机”，或者 Babel 来学习和使用模块化的编程方式。","tags":[{"name":"js模块化","slug":"js模块化","permalink":"//hydesong.github.io/tags/js模块化/"}]},{"title":"摄影日记","date":"2017-03-29T08:02:10.000Z","path":"2017/03/29/pics/","text":"古韵美女","tags":[{"name":"摄影","slug":"摄影","permalink":"//hydesong.github.io/tags/摄影/"}]}]