[{"title":"web前端开发必看的14本书！","date":"2017-09-21T16:18:22.000Z","path":"2017/09/22/web前端开发必看的14本书！/","text":"css 《CSS权威指南》第三版 《CSS那些事儿》 《精通CSS：高级Web标准解决方案》第二版 《CSS禅意花园》 javascript 《JavaScriptDOM编程艺术》 《JavaScript权威指南》第6版 《JavaScript高级程序设计》第三版 《高性能JavaScript》 《JavaScript王者归来》 《JavaScript模式》 《JavaScript设计模式》 jQUery 《锋利的jQuery》第二版 性能 《高性能网站建设指南》 《web敏捷开发之道》","tags":[]},{"title":"this、apply、call、bind（补充）","date":"2017-09-21T14:50:39.000Z","path":"2017/09/21/this、apply、call、bind（补充）/","text":"JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。 例 6：1234567891011var name = \"windowsName\"; function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125; &#125; fn() 例 7： 123456789101112131415161718var name = \"windowsName\"; var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125; &#125;; a.func2() // this.func1 is not a function 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1： 例 1： 12345678910var name = \"windowsName\"; function a() &#123; var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window &#125; a(); console.log(\"outer:\" + this) // outer: Window 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 所以说更多的情况是将函数作为对象的方法使用。比如例 2： 例 2：12345678var name = \"windowsName\"; var a = &#123; name: \"Cherry\", fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; a.fn(); 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(\"Li\",\"Cherry\");a.lastName; // 返回 \"Cherry\" 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ) 这里就简单的来看一下 new 的过程吧： 伪代码表示：12345678var a = new myFunction(\"Li\",\"Cherry\");new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,\"Li\",\"Cherry\"); return typeof result === 'obj'? result : obj;&#125; 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6： 例 6： 1234567891011var name = \"windowsName\"; function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125; &#125; fn() 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的） 然后再看一下 例 7： 例 7：123456789101112131415161718var name = \"windowsName\"; var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125; &#125;; a.func2() // this.func1 is not a function 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。","tags":[{"name":"原生js","slug":"原生js","permalink":"http://hydesong.github.io/tags/原生js/"}]},{"title":"为什么 call 比 apply 快？","date":"2017-09-21T14:05:28.000Z","path":"2017/09/21/为什么-call-比-apply-快？/","text":"本文转载自： https://juejin.im/post/59c0e13b5188257e7a428a83?utm_source=gold_browser_extension 这是一个非常有意思的问题。 在看源码的过程中，总会遇到这样的写法：12345678910var triggerEvents = function(events, args) &#123; var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2]; switch (args.length) &#123; case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return; case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return; case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return; case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return; default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return; &#125;&#125;; （ 代码来自 backbone ） 作者会在参数为3个（包含3）以内时，优先使用 call 方法进行事件的处理。而当参数过多（多余3个）时，才考虑使用 apply 方法。 这个的原因就是 call 比 apply 快。 网上有很多例子全方位的证明了 call 比 apply 快。大家可以看看 call和apply的性能对比 这篇文章中的例子，很全面。或者你也可以自己写几个简单的，测试一下。这里要推荐一个神奇网站 jsperf ，用于测试 js 性能。 几个简单的例子： 为什么call 比 apply 快？这里就要提到他们被调用之后发生了什么。1Function.prototype.apply (thisArg, argArray) 1、如果 IsCallable（Function）为false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 2、如果 argArray 为 null 或未定义，则返回调用 Function 的 [[Call]] 内部方法的结果，提供thisArg 和一个空数组作为参数。 3、如果 Type（argArray）不是 Object，则抛出 TypeError 异常。 4、获取 argArray 的长度。调用 argArray 的 [[Get]] 内部方法，找到属性 length。 赋值给 len。 5、定义 n 为 ToUint32（len）。 6、初始化 argList 为一个空列表。 7、初始化 index 为 0。 8、循环迭代取出 argArray。重复循环 while（index &lt; n） a、将下标转换成String类型。初始化 indexName 为 ToString(index). b、定义 nextArg 为 使用 indexName 作为参数调用argArray的[[Get]]内部方法的结果。 c、将 nextArg 添加到 argList 中，作为最后一个元素。 d、设置 index ＝ index＋1 9、返回调用 Function 的 [[Call]] 内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 1Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] ) 1、如果 IsCallable（Function）为 false，即 Function 不可以被调用，则抛出一个 TypeError 异常。 2、定义 argList 为一个空列表。 3、如果使用超过一个参数调用此方法，则以从arg1开始的从左到右的顺序将每个参数附加为 argList 的最后一个元素 4、返回调用func的[[Call]]内部方法的结果，提供 thisArg 作为该值，argList 作为参数列表。 我们可以看到，明显 apply 比 call 的步骤多很多。由于 apply 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤8）。 同时也有一些对参数的检查（步骤2），在 call 中却是不必要的。 另外一个很重要的点：在 apply 中不管有多少个参数，都会执行循环，也就是步骤 6-8，在 call 中也就是对应步骤3 ，是有需要才会被执行。 综上，call 方法比 apply 快的原因是 call 方法的参数格式正是内部方法所需要的格式。","tags":[{"name":"原生js","slug":"原生js","permalink":"http://hydesong.github.io/tags/原生js/"}]},{"title":"this、apply、call、bind","date":"2017-09-21T13:47:03.000Z","path":"2017/09/21/10/","text":"这又是一个面试经典问题~/(ㄒoㄒ)/~~也是 ES5中众多坑中的一个，在 ES6 中可能会极大避免 this 产生的错误，但是为了一些老代码的维护，最好还是了解一下 this 的指向和 call、apply、bind 三者的区别。 本文首发于：cherryblog.site/ this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子： 例 1：12345678910var name = \"windowsName\"; function a() &#123; var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window &#125; a(); console.log(\"outer:\" + this) // outer: Window 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。 再看下这个例子：例 2：12345678var name = \"windowsName\"; var a = &#123; name: \"Cherry\", fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; a.fn(); 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3：12345678var name = \"windowsName\"; var a = &#123; name: \"Cherry\", fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn(); 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4： 12345678var name = \"windowsName\"; var a = &#123; // name: \"Cherry\", fn : function () &#123; console.log(this.name); // undefined &#125; &#125; window.a.fn(); 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5： 1234567891011var name = \"windowsName\"; var a = &#123; name : null, // name: \"Cherry\", fn : function () &#123; console.log(this.name); // windowsName &#125; &#125; var f = a.fn; f(); 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6： 1234567891011var name = \"windowsName\"; function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125; &#125; fn() 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7：123456789101112131415161718var name = \"windowsName\";var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 例 8 ：123456789101112131415161718var name = \"windowsName\"; var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125; &#125;; a.func2() // Cherry 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。 例 9：1234567891011121314151617181920var name = \"windowsName\"; var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125; &#125;; a.func2() // Cherry 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10：12345678910111213141516var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125; &#125;; a.func2() // Cherry 使用 call例 11：12345678910111213141516var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry 使用 bind例 12：12345678910111213141516var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125; &#125;; a.func2() // Cherry apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。call 的语法为： fun.call(thisArg[, arg1[, arg2[, …]]]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.apply(a,[1,2]) // 3 例 14： 123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下 123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.bind(a,1,2) 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用：123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.bind(a,1,2)() // 3","tags":[{"name":"原生js","slug":"原生js","permalink":"http://hydesong.github.io/tags/原生js/"}]},{"title":"babel转码","date":"2017-04-20T03:07:13.000Z","path":"2017/04/20/9/","text":"babel-cli babel-node babel-register babel-core babel-polyfill babel-standalone REPL在线编译器在线转换 ESLint 和 Mocha Traceur转码器","tags":[{"name":"babel","slug":"babel","permalink":"http://hydesong.github.io/tags/babel/"}]},{"title":"datepicker插件封装","date":"2017-04-18T02:30:38.000Z","path":"2017/04/18/8/","text":"fork me on github datepicker插件的封装，不依赖任何第三方库，纯原生js编写。 目录结构 |datepicker|—-|css|——-datepicker.css|—-|js|——-datepicker.js|——-main.js|—–index.html 代码index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 先把html结构搭起来 * index.html */&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui\" /&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"white\" /&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"\"&gt; &lt;meta name=\"format-detection\" content=\"telephone=no, email=no\" /&gt; &lt;title&gt;date picker&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/datepicker.css\"&gt; &lt;style&gt; .datepicker &#123; border: 1px solid #ccc; border-radius: 4px; padding: 5px; height: 24px; line-height: 24px; width: 230px; &#125; .datepicker:focus &#123; outline: 0 none; border: 1px solid #1abc9c; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" class=\"datepicker\"&gt; &lt;script src=\"js/datepicker.js\"&gt;&lt;/script&gt; &lt;script src=\"js/main.js\"&gt;&lt;/script&gt; &lt;script&gt; // var monthData = datepicker.getMonthData(2016, 12); // console.log(JSON.stringify(monthData)) datepicker.init('.datepicker'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; datepicker.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 再把样式写好 * 注意命名规则 * datepicker.css */.ui-datepicker-wrapper &#123; width: 240px; font-size: 16px; color: #666; box-shadow: 2px 2px 8px 2px rgba(128, 128, 128, 0.3); display: none; position: absolute;&#125;.ui-datepicker-wrapper-show&#123; display: block;&#125;.ui-datepicker-wrapper .ui-datepicker-header &#123; padding: 0 20px; height: 50px; line-height: 50px; text-align: center; backgroud: #f0f0f0; border-bottom: 1px solid #ccc; font-weight: bold;&#125;.ui-datepicker-wrapper .ui-datepicker-btn &#123; font-family: serif; font-size: 20px; width: 20px; height: 50px; line-height: 50px; color: #1abc9c; text-align: center; cursor: pointer; text-decoration: none;&#125;.ui-datepicker-wrapper .ui-datepicker-prev-btn &#123; float: left;&#125;.ui-datepicker-wrapper .ui-datepicker-next-btn &#123; float: right;&#125;.ui-datepicker-wrapper .ui-datepicker-body table &#123; width: 100%; border-collapse: collapse;&#125;.ui-datepicker-wrapper .ui-datepicker-body th,.ui-datepicker-wrapper .ui-datepicker-body td &#123; height: 30px; text-align: center;&#125;.ui-datepicker-wrapper .ui-datepicker-body th &#123; font-size: 12px; height: 40px; line-height: 40px;&#125;.ui-datepicker-wrapper .ui-datepicker-body td &#123; border: 1px solid #f0f0f0; font-size: 10px; cursor: pointer;&#125; datepicker.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 封装组件逻辑 * datepicker.js */(function() &#123; var datepicker = &#123;&#125;; datepicker.getMonthData = function(year, month) &#123; var ret = []; if (!year || !month) &#123; var today = new Date(); year = today.getFullYear(); month = today.getMonth() + 1; &#125; var firstDay = new Date(year, month - 1, 1); var firstDayWeekDay = firstDay.getDay(); if (firstDayWeekDay == 0) &#123; firstDayWeekDay = 7; &#125; year = firstDay.getFullYear(); month = firstDay.getMonth() + 1; var lastDayOfLastMonth = new Date(year, month - 1, 0); var lastDateOfLastMonth = lastDayOfLastMonth.getDate(); var preMonthDayCount = firstDayWeekDay - 1; var lastDay = new Date(year, month, 0); var lastDate = lastDay.getDate(); for (var i = 0; i &lt; 7 * 6; i++) &#123; var date = i + 1 - preMonthDayCount; var showDate = date; var thisMonth = month; //上一月 if (date &lt;= 0) &#123; thisMonth = month - 1; showDate = lastDateOfLastMonth + date; &#125; else if (date &gt; lastDate) &#123; //下一月 thisMonth = month + 1; showDate = showDate - lastDate; &#125; if (thisMonth === 0) &#123; thisMonth = 12; &#125; if (thisMonth === 13) &#123; thisMonth = 1; &#125; ret.push(&#123; month: thisMonth, date: date, showDate: showDate &#125;); &#125; return &#123; year: year, month: month, days: ret &#125;; &#125;; window.datepicker = datepicker;&#125;)(); main.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * main.js */(function () &#123; var datepicker = window.datepicker; var monthData,$wrapper; datepicker.buildUI = function (year, month) &#123; monthData = datepicker.getMonthData(year, month); var html = '&lt;div class=\"ui-datepicker-header\"&gt;&lt;a href=\"#\" class=\"ui-datepicker-btn ui-datepicker-prev-btn\"&gt;&amp;lt;&lt;/a&gt;&lt;a href=\"#\" class=\"ui-datepicker-btn ui-datepicker-next-btn\"&gt;&amp;gt;&lt;/a&gt;&lt;span class=\"ui-datepicker-curr-month\"&gt;' + monthData.year + '-' + monthData.month + '&lt;/span&gt;&lt;/div&gt;&lt;div class=\"ui-datepicker-body\"&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;一&lt;/th&gt;&lt;th&gt;二&lt;/th&gt;&lt;th&gt;三&lt;/th&gt;&lt;th&gt;四&lt;/th&gt;&lt;th&gt;五&lt;/th&gt;&lt;th&gt;六&lt;/th&gt;&lt;th&gt;日&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;'; for (var i = 0; i &lt; monthData.days.length; i++) &#123; var date = monthData.days[i]; if (i % 7 === 0) &#123; html += '&lt;tr&gt;'; &#125; html += '&lt;td data-date=\"'+date.date+'\"&gt;' + date.showDate + '&lt;/td&gt;'; if (i % 7 === 6) &#123; html += '&lt;/tr&gt;'; &#125; &#125; html += '&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;'; return html; &#125;; datepicker.render = function(direction)&#123; var year,month; if(monthData)&#123; year = monthData.year; month = monthData.month; &#125; //console.log(direction); if(direction === 'prev')&#123; month--; &#125; if(direction === 'next')&#123; month++; &#125; if (month == 0) &#123; year--; month = 12; &#125; if (month == 13) &#123; year++; month = 1; &#125; var html = datepicker.buildUI(year,month); $wrapper = document.querySelector('.ui-datepicker-wrapper'); if (!$wrapper) &#123; $wrapper = document.createElement('div'); document.body.appendChild($wrapper); $wrapper.className = 'ui-datepicker-wrapper'; &#125; $wrapper.innerHTML = html; &#125;; datepicker.init = function (input) &#123; datepicker.render(); var $input = document.querySelector(input); var isOpen = false; $input.addEventListener('click', function () &#123; if (isOpen) &#123; $wrapper.classList.remove('ui-datepicker-wrapper-show'); isOpen = false; &#125; else &#123; $wrapper.classList.add('ui-datepicker-wrapper-show'); var left = $input.offsetLeft; var top = $input.offsetTop; var height = $input.offsetHeight; $wrapper.style.top = top + height + 2 + 'px'; $wrapper.style.left = left + 'px'; isOpen = true; &#125; &#125;, false); $wrapper.addEventListener('click',function (e) &#123; var $target = e.target; if(!$target.classList.contains('ui-datepicker-btn')) return; //上一月 if($target.classList.contains('ui-datepicker-prev-btn'))&#123; //console.log('prev'); //document.body.removeChild($wrapper); datepicker.render('prev'); //$wrapper.classList.add('ui-datepicker-wrapper-show'); &#125;else if($target.classList.contains('ui-datepicker-next-btn'))&#123; //下一月 //console.log('next'); //document.body.removeChild($wrapper); datepicker.render('next'); //$wrapper.classList.add('ui-datepicker-wrapper-show'); &#125; &#125;,false); $wrapper.addEventListener('click',function (e) &#123; var $target = e.target; if($target.tagName.toLowerCase() !== 'td') return; var date = new Date(monthData.year, monthData.month-1,$target.dataset.date); $input.value = format(date); $wrapper.classList.remove('ui-datepicker-wrapper-show'); isOpen = false; &#125;,false); &#125; function format(date)&#123; var ret = ''; var padding = function(num)&#123; if(num &lt; 9)&#123; return '0'+ num; &#125; return num; &#125; ret += date.getFullYear() + '-'; ret += padding(date.getMonth() + 1) + '-'; ret += padding(date.getDate()); return ret; &#125;&#125;)();","tags":[{"name":"插件","slug":"插件","permalink":"http://hydesong.github.io/tags/插件/"}]},{"title":"微信蓝牙连接心率设备实时显示心率数据","date":"2017-04-10T09:03:25.000Z","path":"2017/04/10/7/","text":"项目级别：demo项目背景：微信新出蓝牙接口，fizzo公司生产的心率设备有连接微信的需求，需要我做一个demo 话不多说，上代码（只开放了js的代码）： 搜索设备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 搜索设备 **/Page(&#123; data: &#123; logs: [], list: [] &#125;, onLoad: function () &#123; console.log('onLoad'); var that = this; wx.openBluetoothAdapter(&#123; success: function (res) &#123; // success console.log(\"-----success----------\"); console.log(res); wx.startBluetoothDevicesDiscovery(&#123; services: [], success: function (res) &#123; // success console.log(\"-----startBluetoothDevicesDiscovery--success----------\"); console.log(res); &#125;, fail: function (res) &#123; // fail console.log(\"-----startBluetoothDevicesDiscovery--fail----------\"); console.log(res); &#125;, complete: function (res) &#123; // complete console.log(\"-----startBluetoothDevicesDiscovery--complete----------\"); console.log(res); &#125; &#125;) &#125;, fail: function (res) &#123; console.log(\"-----fail----------\"); // fail console.log(res); &#125;, complete: function (res) &#123; // complete console.log(\"-----complete----------\"); console.log(res); &#125; &#125;); wx.getBluetoothDevices(&#123; success: function (res) &#123; // success //&#123;devices: Array[11], errMsg: \"getBluetoothDevices:ok\"&#125; console.log(\"-----getBluetoothDevices--success----------\"); console.log(res); that.setData(&#123; list: res.devices &#125;); console.log(that.data.list); &#125;, fail: function (res) &#123; // fail console.log(\"-----getBluetoothDevices--fail----------\"); &#125;, complete: function (res) &#123; // complete console.log(\"-----getBluetoothDevices--complete----------\"); &#125; &#125;) &#125;, onShow: function () &#123; &#125;, //点击事件处理 bindViewTap: function (e) &#123; console.log(e.currentTarget.dataset.deviceid); console.log(e.currentTarget.dataset.name); console.log(e.currentTarget.dataset.advertisdata); var deviceId = e.currentTarget.dataset.deviceid; var name = e.currentTarget.dataset.name; wx.redirectTo(&#123; url: '../conn/conn?deviceId=' + deviceId + '&amp;name=' + name, success: function (res) &#123; // success console.log(\"-----redirectTo--success----------\"); &#125;, fail: function (res) &#123; // fail console.log(\"-----redirectTo--fail----------\"); &#125;, complete: function (res) &#123; // complete console.log(\"-----redirectTo--complete----------\"); &#125; &#125;) &#125; &#125;); 实时显示心率设备123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 连接设备,获取数据 */Page(&#123; data: &#123; deviceId: '', serviceId: '', characteristicId: '', hr: '--' &#125;, onLoad: function (opt) &#123; var that = this; that.setData(&#123;deviceId: opt.deviceId&#125;); /** * 监听设备的连接状态 */ wx.onBLEConnectionStateChanged(function (res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`) &#125;) /** * 连接设备 */ wx.createBLEConnection(&#123; deviceId: that.data.deviceId, success: function (res) &#123; /** * 连接成功，后开始获取设备的服务列表 */ wx.getBLEDeviceServices(&#123; // 这里的 deviceId 需要在上面的 getBluetoothDevices中获取 deviceId: that.data.deviceId, success: function (res) &#123; for (let i = 0; i &lt; res.services.length; i++) &#123; if (res.services[i].uuid.indexOf('0000180d', 0) != -1) &#123; that.setData(&#123;serviceId: res.services[i].uuid&#125;); &#125; &#125; /** * 延迟,根据服务获取特征 */ setTimeout(function () &#123; //根据服务获取特征值 wx.getBLEDeviceCharacteristics(&#123; deviceId: that.data.deviceId, serviceId: that.data.serviceId, success: function (res) &#123; for (let i = 0; i &lt; res.characteristics.length; i++) &#123; if (res.characteristics[i].uuid.indexOf('00002a37', 0) != -1) &#123; that.setData(&#123;characteristicId: res.characteristics[i].uuid&#125;); &#125; &#125; wx.notifyBLECharacteristicValueChanged(&#123; state: true, deviceId: that.data.deviceId, serviceId: that.data.serviceId, characteristicId: that.data.characteristicId, success: function (res) &#123; wx.onBLECharacteristicValueChange(function (res) &#123; console.log(res); console.log(`characteristic $&#123;res.characteristicId&#125; has changed, now is $&#123;that.buf2hex(res.value)&#125;`); //eg:0671ae000000df07 其中71表示心率 let hrStr = that.buf2hex(res.value).substring(2, 4); let HR = parseInt(hrStr, 16); that.setData(&#123;hr: HR&#125;); console.log(that.buf2hex(res.value)); console.log(HR); console.log(res.value.byteLength); &#125;); &#125; &#125;); &#125;, fail: function (res) &#123; console.log(res); &#125; &#125;); &#125;, 100); &#125; &#125;) &#125;, fail: function (res) &#123; // fail &#125;, complete: function (res) &#123; // complete &#125; &#125;) &#125;, /** * ArrayBuffer 转换为 Hex */ buf2hex: function (buffer) &#123; // buffer is an ArrayBuffer return Array.prototype.map.call(new Uint8Array(buffer), x =&gt; ('00' + x.toString(16)).slice(-2)).join(''); &#125;&#125;) 实际效果 扫描结果 实时心率","tags":[{"name":"心率","slug":"心率","permalink":"http://hydesong.github.io/tags/心率/"}]},{"title":"再谈 CSS 预处理器","date":"2017-04-07T12:41:41.000Z","path":"2017/04/07/6/","text":"再谈 CSS 预处理器","tags":[{"name":"CSS预处理器","slug":"CSS预处理器","permalink":"http://hydesong.github.io/tags/CSS预处理器/"}]},{"title":"微信小程序蓝牙demo","date":"2017-04-01T08:29:59.000Z","path":"2017/04/01/5/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//hr.jsPage(&#123; data: &#123; hr: '--' &#125;, onLoad: function () &#123; &#125;, onShow: function () &#123; /*流程：先初始化蓝牙适配器，然后获取本机蓝牙适配器的状态，然后开始搜索，当停止搜索以后在开始搜索，就会触发蓝牙是配置状态变化的事件，搜索完成以后获取所有已经发现的蓝牙设备，就可以将devices中的设备Array取出来了。*/ this.openBluetooth(); this.getBluetoothAdapterState(); this.startBluetoothDevicesDiscovery(); this.stopBluetoothDevicesDiscovery(); this.startBluetoothDevicesDiscovery(); this.onBluetoothAdapterStateChange(); this.getBluetoothDevices(); this.onBluetoothDeviceFound(); &#125;, // 初始化蓝牙适配器 openBluetooth: function () &#123; wx.openBluetoothAdapter(&#123; success: function (res) &#123; console.log('获取本机蓝牙适配器状态 res:' + JSON.stringify(res)); wx.showToast(&#123; title: \"初始化蓝牙适配器成功\", duration: 2000 &#125;); &#125;, &#125;) &#125;, // 关闭蓝牙模块 closeBluetooth: function () &#123; wx.openBluetoothAdapter(); wx.closeBluetoothAdapter(&#123; success: function (res) &#123; console.log(\"关闭蓝牙模块 res:\" + JSON.stringify(res)) &#125; &#125;); &#125;, // 获取本机蓝牙适配器状态 getBluetoothAdapterState: function () &#123; wx.getBluetoothAdapterState(&#123; success: function (res) &#123; console.log('获取本机蓝牙适配器状态 res:' + JSON.stringify(res)); &#125; &#125;); &#125;, // 监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange: function () &#123; wx.onBluetoothAdapterStateChange(function (res) &#123; console.log('监听蓝牙适配器状态变化事件 res:' + JSON.stringify(res)); &#125;); &#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery: function () &#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log('开始搜寻附近的蓝牙外围设备 res:' + JSON.stringify(res)); &#125; &#125;); &#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery: function () &#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log('停止搜寻附近的蓝牙外围设备 res:' + JSON.stringify(res)); &#125; &#125;); &#125;, // 获取所有已发现的蓝牙设备 getBluetoothDevices: function () &#123; wx.getBluetoothDevices(&#123; success: function (res) &#123; console.log('获取所有已发现的蓝牙设备 res:' + JSON.stringify(res)); &#125; &#125;); &#125;, // 监听寻找到新设备的事件 onBluetoothDeviceFound: function () &#123; wx.onBluetoothDeviceFound(function (res) &#123; console.log('监听寻找到新设备的事件 res:' + JSON.stringify(res)); &#125;); &#125;, // 根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices: function () &#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log('根据 uuid 获取处于已连接状态的设备 res:' + JSON.stringify(res)); &#125; &#125;); &#125;, // 连接低功耗蓝牙设备 createBLEConnection: function () &#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(JSON.stringify(res)) &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;) &#125;, // 断开与低功耗蓝牙设备的连接 closeBLEConnection: function () &#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(JSON.stringify(res)) &#125; &#125;) &#125;, // 监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等 onBLEConnectionStateChanged: function () &#123; wx.onBLEConnectionStateChanged(function (res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`) &#125;) &#125;, // 获取蓝牙设备所有 service（服务） getBLEDeviceServices: function () &#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function (res) &#123; console.log('device services:', res.services.serviceId) &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;) &#125;, // 获取蓝牙设备所有 characteristic（特征值） getBLEDeviceCharacteristics: function () &#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function (res) &#123; &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;) &#125;, // 读取低功耗蓝牙设备的特征值的二进制数据值。 readBLECharacteristicValue: function () &#123; wx.readBLECharacteristicValue(&#123; deviceId: deviceId, serviceId: serviceId, characteristicId: characteristicId, success: function (res) &#123; console.log('readBLECharacteristicValue:', res.characteristic.value) &#125; &#125;) &#125;, // 向低功耗蓝牙设备特征值中写入二进制数据。 writeBLECharacteristicValue: function () &#123; // 向蓝牙设备发送一个0x00的16进制数据 let buffer = new ArrayBuffer(1) let dataView = new DataView(buffer) dataView.setUint8(0, 0) wx.writeBLECharacteristicValue(&#123; deviceId: deviceId, serviceId: serviceId, characteristicId: characteristicId, value: buffer, success: function (res) &#123; console.log('writeBLECharacteristicValue success', res.errMsg) &#125; &#125;) &#125;, // 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 onBLECharacteristicValueChange: function () &#123; console.log(`characteristic $&#123;res.characteristicId&#125; has changed, now is $&#123;res.value&#125;`); &#125;, // 启用低功耗蓝牙设备特征值变化时的 notify 功能。 notifyBLECharacteristicValueChanged: function () &#123; wx.notifyBLECharacteristicValueChanged(&#123; state: true, deviceId: deviceId, serviceId: serviceId, characteristicId: characteristicId, success: function (res) &#123; console.log('notifyBLECharacteristicValueChanged success', res.errMsg) &#125; &#125;) &#125;&#125;)","tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"http://hydesong.github.io/tags/蓝牙/"}]},{"title":"国外图书网站","date":"2017-03-30T11:14:48.000Z","path":"2017/03/30/4/","text":"外文技术类书籍smashingmagazine https://www.smashingmagazine.com/","tags":[{"name":"技术书籍","slug":"技术书籍","permalink":"http://hydesong.github.io/tags/技术书籍/"}]},{"title":"ECMAScript 6 入门","date":"2017-03-30T10:44:44.000Z","path":"2017/03/30/3/","text":"ECMAScript 6 入门","tags":[{"name":"随笔","slug":"随笔","permalink":"http://hydesong.github.io/tags/随笔/"}]},{"title":"小程序开放新能力","date":"2017-03-30T10:31:38.000Z","path":"2017/03/30/1/","text":"为帮助开发者提供更加丰富的服务，小程序新增： 1、低功耗蓝牙小程序可以搜索和连接周边的蓝牙设备，并与之通讯。 2、卡券能力开发者可在小程序中应用卡券能力。小程序内支持领取卡券，会员卡内可直达小程序服务 ，方便用户享受会员权益。 3、共享微信通讯地址经用户授权后，小程序可以直接获取用户在微信中保存的通讯地址，不必再让用户重复输入。 4、获取用户访问场景开发者可以获知当前用户进入小程序的渠道，从而提供差异化服务。如针对到店扫码访问小程序的顾客，发放专属优惠。 5、兼容ES6 API开发者可以在小程序中使用ES6的绝大多数API，而不用考虑JavaScript版本兼容问题。","tags":[{"name":"小程序","slug":"小程序","permalink":"http://hydesong.github.io/tags/小程序/"}]},{"title":"js模块 Modules","date":"2017-03-30T10:31:31.000Z","path":"2017/03/30/2/","text":"早在2007年我刚加入Mozilla的JavaScript团队的时候广为流传一个笑话：通常来说JavaScript程序的长度只有一行。那时候Google Maps的诞龄还只有两岁，在它诞生之前，JavaScript主要被用来验证表单，毫无疑问，每一个处理&lt;input onchange=&gt;的程序真的就只有一行代码。今非昔比，JavaScript项目的规模已经成长到令人惊叹的地步，社区也开发了很多工具来协助构建这些规模庞大的应用。诸多工具中最核心的非模块系统莫 属，在这样一个系统中，你可以通过多个文件和目录来组织你的项目，最重要的是，所有代码都可以按需彼此访问并高效加载。所以JavaScript就这么顺 理成章地拥也了几个知名的模块系统。当然，随之而来的还有几个包管理器，可以用它们安装所有软件以及处理高层次的依赖。如此一来，你一定会觉得ES6的模 块语法真是姗姗来迟啊。好的，那今天我们就一起看看ES6中新增的模块系统，探讨一下我们可以通过新语法打造什么样的工具并进一步推动未来标准的发展。但是首先，我们还是来了解一下ES6模块的基础知识。 模块基础知识每一个ES6模块都是一个包含JS代码的文件，模块本质上就是一段脚本，而不是用module关键字定义一个模块，但是模块与脚本还是有两点区别： 在ES6模块中，无论你是否加入“use strict;”语句，默认情况下模块都是在严格模式下运行。 在模块中你可以使用import和export关键字。 我们先来讨论export。默认情况下，你在模块中的所有声明相对于模块而言都是寄存在本地的。如果你希望公开在模块中声明的内容，并让其它模块加以使用，你一定要导出这些功能。想要导出模块的功能有很多方法，其中最简单的方式是添加export关键字。 123456789101112131415// kittydar.js - 找到一幅图像中所有猫的位置// （事实上是Heather Arthur写的这个库）// （但是她没有使用ES6中新的模块特性，因为那时候是2013年）export function detectCats(canvas, options) &#123; var kittydar = new Kittydar(options); return kittydar.detectCats(canvas);&#125;export class Kittydar &#123; ... 处理图片的几种方法 ...&#125;// 这个helper函数没有被export。function resizeCanvas() &#123; ...&#125;... 你可以导出所有的最外层函数、类以及var、let或const声明的变量。 了解这些，你就可以编写一个简单的模块。你不需要将所有代码都放在一个IIFE或回调中，你只需要在模块中解放手脚，声明你需要的所有内容。代码就是模块，不是一段脚本，所以所有的声明都被限定在模块的作用域中，对所有脚本和模块全局不可见。你需要做的是将组成模块公共API的声明全部导出。 在模块中，除export之外的代码无异于普通代码，你可以访问类似Object和Array这样的全局对象。如果你在web浏览器中运行模块，你甚至可以使用document对象和XMLHttpRequest对象。 在一个独立文件中，我们可以导入detectCats()函数然后用它来做点儿什么：1234567// demo.js - Kittydar的demo程序import &#123;detectCats&#125; from \"kittydar.js\";function go() &#123; var canvas = document.getElementById(\"catpix\"); var cats = detectCats(canvas); drawRectangles(canvas, cats);&#125; 如果想从一个模块中导入多个名称，你可以这样写：1import &#123;detectCats, Kittydar&#125; from \"kittydar.js\"; 当你运行的模块中包含一条import声明时，首先会加载被导入的模块；然后依赖图的深度优先遍历按顺序执行每一个模块的主体代码；为了避免形成回环，所有已执行的模块都会被忽略。 这些就是模块的基本知识了，相当简单吧。 Export列表你不需要标记每一个被导出的特性，你只需要在花括号中按照列表的格式写下你想导出的所有名称：1234export &#123;detectCats, Kittydar&#125;;// 此处不需要 `export`关键字function detectCats(canvas, options) &#123; ... &#125;class Kittydar &#123; ... &#125; export列表可以在模块文件最外层作用域的每一处声明，不一定非要把它放在模块文件的首行。你也可以声明多个export列表，甚至通过其它的export声明打造一个混合的export列表，只要保证每一个被导出的名称是唯一的即可。 重命名import和export恰恰有时候，导出的名称会与你需要使用的其它名称产生冲突，ES6为你提供了重命名的方法解决这个问题，当你在导入名称时可以这样做：123456// suburbia.js// 这两个模块都会导出以`flip`命名的东西。// 要同时导入两者，我们至少要将其中一个的名称改掉。import &#123;flip as flipOmelet&#125; from \"eggs.js\";import &#123;flip as flipHouse&#125; from \"real-estate.js\";... 同样，当你在导出的时候也可以重命名。你可能会想用两个不同的名称导出相同的值，这样的情况偶尔也会遇到：123456789// unlicensed_nuclear_accelerator.js - 无DRM（数字版权管理）的媒体流// （这不是一个真实存在的库，但是或许它应该被做成一个库）function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; Default exports现在广泛使用的模块系统有CommonJS、AMD两种，设计出来的新标准可以与这两种模块进行交互。所以假设你有一个Node项目，你已经执行了npm install lodash，你的ES6模块可以从Lodash中导入独立的函数：12import &#123;each, map&#125; from \"lodash\";each([3, 2, 1], x =&gt; console.log(x)); 但是也许你已经习惯看到.each的书写方式而不想直接用each函数呢？或者你就真的想导入整个函数呢，毕竟_对于Lodash而言至关重要。 针对这种情况，你可以换用一种稍微不太一样的方法：不用花括号来导入模块。1import _ from \"lodash\"; 这种简略的表达方法等价于import {default as _} from “lodash”;。在ES6的模块中导入的CommonJS模块和AMD模块都有一个默认的导出，如果你用require()加载这些模块也会得到相同的结果——exports对象。 ES6模块不只导出CommonJS模块，它的设计逻辑为你提供导出不同内容的多种方法，默认导出的是你得到的所有内容。举个例子，在用这种写法的时候，据我所知，著名的colors包就没有任何针对ES6的支持。像大多数npm上的包一样，它是诸多CommonJS模块的集合，但是你可以正确地将它导入到你的ES6代码中。12// `var colors = require(\"colors/safe\");`的ES6等效代码import colors from \"colors/safe\"; 如果你想让自己的ES6模块有一个默认的导出，实现的方法很简单，默认导出与其它类型的导出相似，没有什么技巧可言，唯一的不同之处是它被命名为“default”。你可以用我们刚才讨论的重命名语法来实现：12345let myObject = &#123; field1: value1, field2: value2&#125;;export &#123;myObject as default&#125;; 这种简略的表达方法看起来更清爽：1234export default &#123; field1: value1, field2: value2&#125;; 关键字export default后可跟随任何值：一个函数、一个类、一个对象字面量，只要你能想到的都可以。 模块对象很抱歉新特性有点儿多，但JavaScript不是唯一这样做的语言：出于某些原因，每一种语言中的模块系统都有这么一堆又独立又小，虽然无聊但是很方便的特性。不过还好，我们只剩一样东西没讲了。好吧，是两样。1import * as cows from \"cows\"; 当你import *时，导入的其实是一个模块命名空间对象，模块将它的所有属性都导出了。所以如果“cows”模块导出一个名为moon()的函数，然后用上面这种方法“cows”将其全部导入后，你就可以这样调用函数了：cows.moon()。 聚合模块有时一个程序包中主模块的代码比较多，为了简化这样的代码，可以用一种统一的方式将其它模块中的内容聚合在一起导出，可以通过这种简单的方式将所有所需内容导入再导出：1234567// world-foods.js - 来自世界各地的好东西// 导入\"sri-lanka\"并将它导出的内容的一部分重新导出export &#123;Tea, Cinnamon&#125; from \"sri-lanka\";// 导入\"equatorial-guinea\"并将它导出的内容的一部分重新导出export &#123;Coffee, Cocoa&#125; from \"equatorial-guinea\";// 导入\"singapore\"并将它导出的内容全部导出export * from \"singapore\"; 这些export-from语句每一个都好比是在一条import-from语句后伴随着一个export。与真正的导入内容的方法不同的是，这些导入内容再重新导出的方法不会在作用域中绑定你导入的内容。如果你打算用world-foods.js中的Tea来写一些代码，可别用这种方法导入模块，你会发现当前模块作用域中根本找不到Tea。 如果从“singapore”导出的任何名称碰巧与其它的导出冲突了，可能会触发一个错误，所以使用export *语句的时候要格外小心。 呼！终于讲完了所有的语法！现在来讲一些有趣的内容。 import实际都做了些什么？如果我说它什么都没做，你敢信？ 哦，看来你没那么容易上当啊。好吧，你相信标准里面通常都不会规定import的行为么？如果真是这样，那这是件好事儿么？ ES6将模块加载过程的细节完全交由最终的实现来定义，模块执行的其它部分倒是在规范中有详细定义。 粗略地讲，当你通知JS引擎运行一个模块时，它一定会按照以下四个步骤执行下去： 语法解析：阅读模块源代码，检查语法错误。 加载：递归地加载所有被导入的模块。这也正是没被标准化的部分。 连接：每遇到一个新加载的模块，为其创建作用域并将模块内声明的所有绑定填充到该作用域中，其中包括由其它模块导入的内容。 如果你的代码中有import {cake} from “paleo”这样的语句，而此时“paleo”模块并没有导出任何“cake”，你就会触发一个错误。这实在是太糟糕了，你都快要运行模块中的代码了，都是cake惹的祸！ 运行时：最终，在每一个新加载的模块体内执行所有语句。此时，导入的过程就已经结束了，所以当执行到达有一行import声明的代码的时候……什么都没发生！ 看到了嘛？我可告诉过你结果是“啥都没有”哦。事关编程语言我绝不撒谎！ 但是现在我们真的要深入了解这个系统最有趣的部分了！有一个很酷的小技巧我可以教给你。系统不指定加载过程的实现方式，你也可以通过在源代码中查找import声明提前计算出所有依赖，你可以将ES6系统实现为：在编译时计算所有依赖并将所有模块打包成一个文件，通过网络一次传输所有模块！像webpack这样的工具就实现了这个功能。 这种做法的意义非常深远，因为通过网络加载脚本需要花费时间，每当你请求到一个模块，你可能发现它里面也包含着import声 明，这就需要你再花费一些时间加载更多的脚本。基于如此天真的思想实现的加载器需要消耗更多的网络往返时间。但是webpack就不一样啦，它所用的加载 器是经过精心设计的，吸收了软件工程领域的精华，所以你不仅可以立即开始使用ES6模块系统，还不会损耗运行时的性能。 最初的时候，标准委员会已经制定并实现了详细的ES6模块加载标准，它未成为最终的标准的原因是成员们没有就代码封包（bundle）功能的实现方式达成一 致意见。我希望有人能搞定这个问题，正如我们所见，模块加载的过程亟待被标准化；最关键的是，封包的功能实在是太好，就这样放弃对其进行标准化有些可惜啊。 静态vs动态：论规则及破例之法JavaScript作为一门动态语言已经得到了一个令人惊讶的静态模块系统。 你只可以在模块的最外层作用域使用import和export，不可在条件语句中使用，也不能在函数作用域中使用import。 所有导出的标识符一定要在源代码中明确地导出它们的名称，你不能通过编写代码遍历一个数组然后用数据驱动的方式导出一堆名称。 模块对象被冻结了，所以你无法hack模块对象并为其添加polyfill风格的新特性。 一个模块的所有依赖必须在模块代码运行前完全加载、解析并且及早连接，不存在一种通过import来按需懒加载的语法。 import模块产生的错误没有错误恢复机制。一个app可能囊括了上百个模块，一旦有一个模块无法加载或连接，所有的模块都不会运行，而且你不能在try/catch代码块中捕捉import的错误信息。（上面这些描述的本意是说：系统是静态的，webpack可在编译时为你检测那些错误。） 不支持在模块加载依赖前运行其它代码的钩子，这也意味着无法控制模块的依赖加载过程。 只要你的需求是静态的，系统就会运行良好，但是你有时可以设想下需要一点儿hack，对么？ 这也就是无论你用什么模块加载系统，你都将有一个编程API来支持ES6的静态import/export语法。举个例子，webpack中引入了一个“代码分割”API，从而可以按需懒加载一些模块的多个封包。相同的API可以帮你打破上面列举的绝大多数其它的规则。 ES6模块语法非常静态，这是很好的——它通过强有力的编译时工具的形式进行弥补。但是设计静态语法的初衷是要与丰富的动态编程加载器API一起增强ES6的模块系统。 我什么时候可以使用ES6模块？如果你现在就想在项目中加入新的模块语法，你需要使用Babel或Traceur这样的转译器。","tags":[{"name":"模块化","slug":"模块化","permalink":"http://hydesong.github.io/tags/模块化/"}]}]